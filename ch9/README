Chapter 9: Lists

"If the doors of perception were cleansed, everything would appear to man as it
is - infiinte" - William Blake

-- Notes --

Lists serve as a way to refer to and process a collection of values and as an
infinite series of values, usually generated by a function, that can act as a
stream datatype.

`data [] a = [] | a : [a]`

The above data declaration defines `[]` as a type constructor and data constructor
for the list type. The first data constructor represents an empty list. The second
data constructor (:) takes two arguments and is known as the "cons" operator. It
adds the first argument to a list containing arguments of a simiar type.

Pattern matching against a list uses the (:) operator to distinguish the head
element of a list from the remaining tail.

Lists use syntactic sugar to allow building without the use of successive (:)
applications. This includes using concat or the (++) operator to combine lists
and declaring lists using [x, y, z] syntax.

Ranges are one of the simplest ways to construct lists. We can use the range
synaxt, e.g. [1..10] or [1,3..10], or the equivalent functions within the Enum
typeclass, e.g. `enumFromTo 1 10` or `enumFromThenTo 1 3 10`
functions or (..)

List comprehensions are a means of generating a new list from a list or lists.
There must be at least one list, the generator, which gies the input for the
comprehension (the set of source items that will be used to construct the new
list/s). An output function can also be applied to each element of the new
list.

List comprehensions can optionally take predicates that limit the elements
taken from the list. Thus we can have multiple generators and predicates
that test properties of the values taken from those generators. Those which
pass inspection will be fed to a function. The resulting value is added to
a new list. In the case of multiple generators, the rightmost list will be
exhausted first.

Note: List comprehensions work with strings.

Lists are a recursive series of cons cells terminated by the empty list,
i.e. a : (a : (a : [])). Data structures in Haskell, particularly lists,
sequences, and trees have a notion of a spine. The spine is a connective
structure that ties the collection of values together. W.R.T a list, the
spine is the recursive cons (:) operators (note: the operators, not the
entire cons cells).

Since evaluation is non-strict, individual elements within a list are not
evaluated until they have to be. This can result in a partially evaluated
list of items.

For performance sensitive code it is best to follow the mantra, "lazy in
the spine, strict in the leaves."

Zipping lists together is a means of combining the elements from multiple
lists into a single list. We can use `zipWith` to add a combining function.
This will allow us to control the resulting lists elements.

`zip`     :: [a] -> [b] -> [(a, b)]
`unzip`   :: [(a, b)] -> ([a], [b])
`zipWith` :: (a -> b -> c) -> [a] -> [b] -> [c]

Unlike list comprehensions, zipping does not create a product of both lists.
Each value in a list is only found once in the resulting, "zipped" list. The
zipping process is stopped once one of the lists is exhausted. Simliar to a
pairwise operation.

-- Terminology & Concepts --

-- Follow-up Resources --
